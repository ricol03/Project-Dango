int displayimagefromurl(HWND hwnd, const char * imageurl) {
    int width, height, channels;
    
    char imgbuffer[256];
    sprintf(imgbuffer, "image_%d.jpg", rand());
    localfile = imgbuffer;


    char url[1024];
    strncpy(url, imageurl, sizeof(url) - 1);
    url[sizeof(url) - 1] = '\0';

    /*int size = MultiByteToWideChar(CP_ACP, 0, imageurl, -1, NULL, 0);
    wchar_t* wstr = (wchar_t*)malloc(size * sizeof(wchar_t));
    MultiByteToWideChar(CP_ACP, 0, imageurl, -1, wstr, size);*/

    //Cria um handle de sessão de hinternet
    HINTERNET hsession = WinHttpOpen(L"Nossa/1.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
    if (hsession == NULL) {
        MessageBox(hwnd, "WinHttpOpen failed!", "Error", MB_ICONERROR);
        return -1;
    }

    //Estabelece contacto com o domínio especificado
    HINTERNET hconnect = WinHttpConnect(hsession, L"s4.anilist.co", INTERNET_DEFAULT_HTTP_PORT, 0);

    //Cria um pedido HTTP
    HINTERNET hrequest = WinHttpOpenRequest(hconnect, L"GET", L"/file/anilistcdn/media/anime/cover/large/bx2484-cKkTQRNpoAXx.jpg", NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);
    if (hrequest == NULL) {
        printf("%d", GetLastError());
        MessageBox(hwnd, "error", "Error", MB_ICONERROR);
        WinHttpCloseHandle(hsession);
        GetLastError();
        return -1;
    }

    //Envia o pedido HTTP
    if (!WinHttpSendRequest(hrequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0)) {
        MessageBox(hwnd, "WinHttpSendRequest failed!", "Error", MB_ICONERROR);
        printf("%d", GetLastError());
        WinHttpCloseHandle(hrequest);
        WinHttpCloseHandle(hsession);
        return -1;
    }

    if (!WinHttpReceiveResponse(hrequest, NULL)) {
        MessageBox(hwnd, "WinHttpReceiveResponse failed!", "Error", MB_ICONERROR);
        printf("%d", GetLastError());
        WinHttpCloseHandle(hrequest);
        WinHttpCloseHandle(hsession);
        return -1;
    }

    DWORD statusCode = 0;
    DWORD statusCodeSize = sizeof(DWORD);

    if (WinHttpQueryHeaders(hrequest, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, NULL, &statusCode, &statusCodeSize, NULL)) {
        printf("%d", statusCode);
    }

    char filebuffer[256];
    sprintf(filebuffer, ".\\image\\%s", localfile);

    LPTSTR filepath = filebuffer;

    CreateDirectory(".\\image\\", NULL);

    HANDLE hFile = CreateFile(filepath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        MessageBox(hwnd, "Error creating local image file", "Error", MB_ICONERROR);
        return -1;
    }

    BYTE buffer[1024];
    DWORD bytesRead;
    while (WinHttpReadData(hrequest, buffer, sizeof(buffer), &bytesRead) && bytesRead > 0) {
        printf("Bytes read: %lu\n", bytesRead);
        DWORD byteswritten;
        WriteFile(hFile, buffer, bytesRead, &byteswritten, NULL);
        printf("Bytes written: %lu\n", byteswritten);
    }

    CloseHandle(hFile);

    int x, y, n, ok;
    
    ok = stbi_info(localfile, &x, &y, &n);

    unsigned char* image = stbi_load(localfile, &width, &height, &channels, 0); 
    printf("4");

    if (image != NULL) {
        MessageBox(hwnd, "The image was \"displayed\" successfully", "Info", MB_ICONINFORMATION);
        //hbitmap = CreateBitmap(width, height, 1, 32, image);
        InvalidateRect(hwnd, NULL, TRUE);
        stbi_image_free(image);
    } else {
        char buffer[256];
        sprintf(buffer, "Error loading from URL: %s", imageurl);
        MessageBox(hwnd, buffer, "Error", MB_OK | MB_ICONERROR);
    }
    
}

void parsejsonanddisplayimage(HWND hwnd, const char* jsonstring, struct jsonobject jobject) {

    //cria uma string do início da chave da imagem
    const char* imagekey = "\"image\":\"";
    const char* endquote = "\"";

    printf("1");

    //"verifica" se a string imagekey existe na jsonstring
    const char* start = strstr(jsonstring, imagekey);
    printf("\n\n\nEle dá print disto amigo (start): %s", start);

    //se existir
    if (start != NULL) {
        //move o ponteiro para a posição após a string imagekey
        start += strlen(imagekey);

        printf("2");

        const char* end = strstr(start, endquote);
        printf("\n\n\nEle dá print disto amigo (end): %s", end);

        if (end != NULL) {
            printf("3");
            //calcula o tamanho entre o início e o fim do link da imagem
            size_t length = end - start;
            /*printf(sizeof(length));
            printf(sizeof(end));
            printf(sizeof(start));*/
            printf("\n\n\nEle dá print disto amigo: %s", jobject.value);
            //coloca na struct a string da posição start até start + length
            strncpy(jobject.value, start, length);
            //termina a string com um \0
            jobject.value[length] = '\0';

            printf("\n\n\nEle dá print disto amigo (dps do strncpy): %s", jobject.value);
            //usa a mesma string para mostrar a imagem
            displayimagefromurl(hwnd, jobject.value);
        }
        
    }
        
}

/*FreeImage_Initialise(TRUE);

            // Load image
            FIBITMAP* bitmap = FreeImage_Load(FIF_JPEG, localfile, JPEG_DEFAULT);
            if (!bitmap) {
                MessageBox(hwnd, "Failed to load image", "Error", MB_ICONERROR);
            }

            // Get image dimensions
            int width = FreeImage_GetWidth(bitmap);
            int height = FreeImage_GetHeight(bitmap);

            // Create a device context for drawing
            HDC hdcW = GetDC(hwnd);
            
            // Convert FreeImage bitmap to HBITMAP
            HBITMAP hBitmap = FreeImage_LoadFromHandle(bitmap, 0, 0, 0);
            
            // Create a memory device context and select the bitmap into it
            HDC hdcMem = CreateCompatibleDC(hdcW);
            HGDIOBJ oldBitmap = SelectObject(hdcMem, hBitmap);

            // Draw the image to the window
            BitBlt(hdcW, 0, 0, width, height, hdcMem, 0, 0, SRCCOPY);

            // Clean up resources
            SelectObject(hdcMem, oldBitmap);
            DeleteDC(hdcMem);
            FreeImage_Unload(bitmap);
            ReleaseDC(hwnd, hdcW);
            
            FreeImage_DeInitialise();*/